{"parents": [{"link": "../", "title": "All classes"}], "prev": {"link": "../class_gdextensionmanager/", "title": "GDExtensionManager"}, "next": {"link": "../class_geometry3d/", "title": "Geometry3D"}, "title": "Geometry2D", "meta": {"github_url": "hide"}, "body": "<section id=\"geometry2d\">\n<span id=\"class-geometry2d\"></span><h1>Geometry2D<a class=\"headerlink\" href=\"#geometry2d\" title=\"Link to this heading\">\uf0c1</a></h1>\n<p><strong>Inherits:</strong> <a class=\"reference internal\" href=\"../class_object/#class-object\"><span class=\"std std-ref\">Object</span></a></p>\n<p>Provides methods for some common 2D geometric operations.</p>\n<section class=\"classref-introduction-group\" id=\"description\">\n<h2>Description<a class=\"headerlink\" href=\"#description\" title=\"Link to this heading\">\uf0c1</a></h2>\n<p>Provides a set of helper functions to create geometric shapes, compute intersections between shapes, and process various other geometric operations in 2D.</p>\n</section>\n<section class=\"classref-reftable-group\" id=\"methods\">\n<h2>Methods<a class=\"headerlink\" href=\"#methods\" title=\"Link to this heading\">\uf0c1</a></h2>\n<table class=\"docutils align-default\">\n<tbody>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"../class_array/#class-array\"><span class=\"std std-ref\">Array</span></a>[<a class=\"reference internal\" href=\"../class_vector2i/#class-vector2i\"><span class=\"std std-ref\">Vector2i</span></a>]</p></td>\n<td><p><a class=\"reference internal\" href=\"#class-geometry2d-method-bresenham-line\"><span class=\"std std-ref\">bresenham_line</span></a>(from: <a class=\"reference internal\" href=\"../class_vector2i/#class-vector2i\"><span class=\"std std-ref\">Vector2i</span></a>, to: <a class=\"reference internal\" href=\"../class_vector2i/#class-vector2i\"><span class=\"std std-ref\">Vector2i</span></a>)</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"../class_array/#class-array\"><span class=\"std std-ref\">Array</span></a>[<a class=\"reference internal\" href=\"../class_packedvector2array/#class-packedvector2array\"><span class=\"std std-ref\">PackedVector2Array</span></a>]</p></td>\n<td><p><a class=\"reference internal\" href=\"#class-geometry2d-method-clip-polygons\"><span class=\"std std-ref\">clip_polygons</span></a>(polygon_a: <a class=\"reference internal\" href=\"../class_packedvector2array/#class-packedvector2array\"><span class=\"std std-ref\">PackedVector2Array</span></a>, polygon_b: <a class=\"reference internal\" href=\"../class_packedvector2array/#class-packedvector2array\"><span class=\"std std-ref\">PackedVector2Array</span></a>)</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"../class_array/#class-array\"><span class=\"std std-ref\">Array</span></a>[<a class=\"reference internal\" href=\"../class_packedvector2array/#class-packedvector2array\"><span class=\"std std-ref\">PackedVector2Array</span></a>]</p></td>\n<td><p><a class=\"reference internal\" href=\"#class-geometry2d-method-clip-polyline-with-polygon\"><span class=\"std std-ref\">clip_polyline_with_polygon</span></a>(polyline: <a class=\"reference internal\" href=\"../class_packedvector2array/#class-packedvector2array\"><span class=\"std std-ref\">PackedVector2Array</span></a>, polygon: <a class=\"reference internal\" href=\"../class_packedvector2array/#class-packedvector2array\"><span class=\"std std-ref\">PackedVector2Array</span></a>)</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"../class_packedvector2array/#class-packedvector2array\"><span class=\"std std-ref\">PackedVector2Array</span></a></p></td>\n<td><p><a class=\"reference internal\" href=\"#class-geometry2d-method-convex-hull\"><span class=\"std std-ref\">convex_hull</span></a>(points: <a class=\"reference internal\" href=\"../class_packedvector2array/#class-packedvector2array\"><span class=\"std std-ref\">PackedVector2Array</span></a>)</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"../class_array/#class-array\"><span class=\"std std-ref\">Array</span></a>[<a class=\"reference internal\" href=\"../class_packedvector2array/#class-packedvector2array\"><span class=\"std std-ref\">PackedVector2Array</span></a>]</p></td>\n<td><p><a class=\"reference internal\" href=\"#class-geometry2d-method-decompose-polygon-in-convex\"><span class=\"std std-ref\">decompose_polygon_in_convex</span></a>(polygon: <a class=\"reference internal\" href=\"../class_packedvector2array/#class-packedvector2array\"><span class=\"std std-ref\">PackedVector2Array</span></a>)</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"../class_array/#class-array\"><span class=\"std std-ref\">Array</span></a>[<a class=\"reference internal\" href=\"../class_packedvector2array/#class-packedvector2array\"><span class=\"std std-ref\">PackedVector2Array</span></a>]</p></td>\n<td><p><a class=\"reference internal\" href=\"#class-geometry2d-method-exclude-polygons\"><span class=\"std std-ref\">exclude_polygons</span></a>(polygon_a: <a class=\"reference internal\" href=\"../class_packedvector2array/#class-packedvector2array\"><span class=\"std std-ref\">PackedVector2Array</span></a>, polygon_b: <a class=\"reference internal\" href=\"../class_packedvector2array/#class-packedvector2array\"><span class=\"std std-ref\">PackedVector2Array</span></a>)</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"../class_vector2/#class-vector2\"><span class=\"std std-ref\">Vector2</span></a></p></td>\n<td><p><a class=\"reference internal\" href=\"#class-geometry2d-method-get-closest-point-to-segment\"><span class=\"std std-ref\">get_closest_point_to_segment</span></a>(point: <a class=\"reference internal\" href=\"../class_vector2/#class-vector2\"><span class=\"std std-ref\">Vector2</span></a>, s1: <a class=\"reference internal\" href=\"../class_vector2/#class-vector2\"><span class=\"std std-ref\">Vector2</span></a>, s2: <a class=\"reference internal\" href=\"../class_vector2/#class-vector2\"><span class=\"std std-ref\">Vector2</span></a>)</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"../class_vector2/#class-vector2\"><span class=\"std std-ref\">Vector2</span></a></p></td>\n<td><p><a class=\"reference internal\" href=\"#class-geometry2d-method-get-closest-point-to-segment-uncapped\"><span class=\"std std-ref\">get_closest_point_to_segment_uncapped</span></a>(point: <a class=\"reference internal\" href=\"../class_vector2/#class-vector2\"><span class=\"std std-ref\">Vector2</span></a>, s1: <a class=\"reference internal\" href=\"../class_vector2/#class-vector2\"><span class=\"std std-ref\">Vector2</span></a>, s2: <a class=\"reference internal\" href=\"../class_vector2/#class-vector2\"><span class=\"std std-ref\">Vector2</span></a>)</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"../class_packedvector2array/#class-packedvector2array\"><span class=\"std std-ref\">PackedVector2Array</span></a></p></td>\n<td><p><a class=\"reference internal\" href=\"#class-geometry2d-method-get-closest-points-between-segments\"><span class=\"std std-ref\">get_closest_points_between_segments</span></a>(p1: <a class=\"reference internal\" href=\"../class_vector2/#class-vector2\"><span class=\"std std-ref\">Vector2</span></a>, q1: <a class=\"reference internal\" href=\"../class_vector2/#class-vector2\"><span class=\"std std-ref\">Vector2</span></a>, p2: <a class=\"reference internal\" href=\"../class_vector2/#class-vector2\"><span class=\"std std-ref\">Vector2</span></a>, q2: <a class=\"reference internal\" href=\"../class_vector2/#class-vector2\"><span class=\"std std-ref\">Vector2</span></a>)</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"../class_array/#class-array\"><span class=\"std std-ref\">Array</span></a>[<a class=\"reference internal\" href=\"../class_packedvector2array/#class-packedvector2array\"><span class=\"std std-ref\">PackedVector2Array</span></a>]</p></td>\n<td><p><a class=\"reference internal\" href=\"#class-geometry2d-method-intersect-polygons\"><span class=\"std std-ref\">intersect_polygons</span></a>(polygon_a: <a class=\"reference internal\" href=\"../class_packedvector2array/#class-packedvector2array\"><span class=\"std std-ref\">PackedVector2Array</span></a>, polygon_b: <a class=\"reference internal\" href=\"../class_packedvector2array/#class-packedvector2array\"><span class=\"std std-ref\">PackedVector2Array</span></a>)</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"../class_array/#class-array\"><span class=\"std std-ref\">Array</span></a>[<a class=\"reference internal\" href=\"../class_packedvector2array/#class-packedvector2array\"><span class=\"std std-ref\">PackedVector2Array</span></a>]</p></td>\n<td><p><a class=\"reference internal\" href=\"#class-geometry2d-method-intersect-polyline-with-polygon\"><span class=\"std std-ref\">intersect_polyline_with_polygon</span></a>(polyline: <a class=\"reference internal\" href=\"../class_packedvector2array/#class-packedvector2array\"><span class=\"std std-ref\">PackedVector2Array</span></a>, polygon: <a class=\"reference internal\" href=\"../class_packedvector2array/#class-packedvector2array\"><span class=\"std std-ref\">PackedVector2Array</span></a>)</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"../class_bool/#class-bool\"><span class=\"std std-ref\">bool</span></a></p></td>\n<td><p><a class=\"reference internal\" href=\"#class-geometry2d-method-is-point-in-circle\"><span class=\"std std-ref\">is_point_in_circle</span></a>(point: <a class=\"reference internal\" href=\"../class_vector2/#class-vector2\"><span class=\"std std-ref\">Vector2</span></a>, circle_position: <a class=\"reference internal\" href=\"../class_vector2/#class-vector2\"><span class=\"std std-ref\">Vector2</span></a>, circle_radius: <a class=\"reference internal\" href=\"../class_float/#class-float\"><span class=\"std std-ref\">float</span></a>)</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"../class_bool/#class-bool\"><span class=\"std std-ref\">bool</span></a></p></td>\n<td><p><a class=\"reference internal\" href=\"#class-geometry2d-method-is-point-in-polygon\"><span class=\"std std-ref\">is_point_in_polygon</span></a>(point: <a class=\"reference internal\" href=\"../class_vector2/#class-vector2\"><span class=\"std std-ref\">Vector2</span></a>, polygon: <a class=\"reference internal\" href=\"../class_packedvector2array/#class-packedvector2array\"><span class=\"std std-ref\">PackedVector2Array</span></a>)</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"../class_bool/#class-bool\"><span class=\"std std-ref\">bool</span></a></p></td>\n<td><p><a class=\"reference internal\" href=\"#class-geometry2d-method-is-polygon-clockwise\"><span class=\"std std-ref\">is_polygon_clockwise</span></a>(polygon: <a class=\"reference internal\" href=\"../class_packedvector2array/#class-packedvector2array\"><span class=\"std std-ref\">PackedVector2Array</span></a>)</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"../class_variant/#class-variant\"><span class=\"std std-ref\">Variant</span></a></p></td>\n<td><p><a class=\"reference internal\" href=\"#class-geometry2d-method-line-intersects-line\"><span class=\"std std-ref\">line_intersects_line</span></a>(from_a: <a class=\"reference internal\" href=\"../class_vector2/#class-vector2\"><span class=\"std std-ref\">Vector2</span></a>, dir_a: <a class=\"reference internal\" href=\"../class_vector2/#class-vector2\"><span class=\"std std-ref\">Vector2</span></a>, from_b: <a class=\"reference internal\" href=\"../class_vector2/#class-vector2\"><span class=\"std std-ref\">Vector2</span></a>, dir_b: <a class=\"reference internal\" href=\"../class_vector2/#class-vector2\"><span class=\"std std-ref\">Vector2</span></a>)</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"../class_dictionary/#class-dictionary\"><span class=\"std std-ref\">Dictionary</span></a></p></td>\n<td><p><a class=\"reference internal\" href=\"#class-geometry2d-method-make-atlas\"><span class=\"std std-ref\">make_atlas</span></a>(sizes: <a class=\"reference internal\" href=\"../class_packedvector2array/#class-packedvector2array\"><span class=\"std std-ref\">PackedVector2Array</span></a>)</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"../class_array/#class-array\"><span class=\"std std-ref\">Array</span></a>[<a class=\"reference internal\" href=\"../class_packedvector2array/#class-packedvector2array\"><span class=\"std std-ref\">PackedVector2Array</span></a>]</p></td>\n<td><p><a class=\"reference internal\" href=\"#class-geometry2d-method-merge-polygons\"><span class=\"std std-ref\">merge_polygons</span></a>(polygon_a: <a class=\"reference internal\" href=\"../class_packedvector2array/#class-packedvector2array\"><span class=\"std std-ref\">PackedVector2Array</span></a>, polygon_b: <a class=\"reference internal\" href=\"../class_packedvector2array/#class-packedvector2array\"><span class=\"std std-ref\">PackedVector2Array</span></a>)</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"../class_array/#class-array\"><span class=\"std std-ref\">Array</span></a>[<a class=\"reference internal\" href=\"../class_packedvector2array/#class-packedvector2array\"><span class=\"std std-ref\">PackedVector2Array</span></a>]</p></td>\n<td><p><a class=\"reference internal\" href=\"#class-geometry2d-method-offset-polygon\"><span class=\"std std-ref\">offset_polygon</span></a>(polygon: <a class=\"reference internal\" href=\"../class_packedvector2array/#class-packedvector2array\"><span class=\"std std-ref\">PackedVector2Array</span></a>, delta: <a class=\"reference internal\" href=\"../class_float/#class-float\"><span class=\"std std-ref\">float</span></a>, join_type: <a class=\"reference internal\" href=\"#enum-geometry2d-polyjointype\"><span class=\"std std-ref\">PolyJoinType</span></a> = 0)</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"../class_array/#class-array\"><span class=\"std std-ref\">Array</span></a>[<a class=\"reference internal\" href=\"../class_packedvector2array/#class-packedvector2array\"><span class=\"std std-ref\">PackedVector2Array</span></a>]</p></td>\n<td><p><a class=\"reference internal\" href=\"#class-geometry2d-method-offset-polyline\"><span class=\"std std-ref\">offset_polyline</span></a>(polyline: <a class=\"reference internal\" href=\"../class_packedvector2array/#class-packedvector2array\"><span class=\"std std-ref\">PackedVector2Array</span></a>, delta: <a class=\"reference internal\" href=\"../class_float/#class-float\"><span class=\"std std-ref\">float</span></a>, join_type: <a class=\"reference internal\" href=\"#enum-geometry2d-polyjointype\"><span class=\"std std-ref\">PolyJoinType</span></a> = 0, end_type: <a class=\"reference internal\" href=\"#enum-geometry2d-polyendtype\"><span class=\"std std-ref\">PolyEndType</span></a> = 3)</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"../class_bool/#class-bool\"><span class=\"std std-ref\">bool</span></a></p></td>\n<td><p><a class=\"reference internal\" href=\"#class-geometry2d-method-point-is-inside-triangle\"><span class=\"std std-ref\">point_is_inside_triangle</span></a>(point: <a class=\"reference internal\" href=\"../class_vector2/#class-vector2\"><span class=\"std std-ref\">Vector2</span></a>, a: <a class=\"reference internal\" href=\"../class_vector2/#class-vector2\"><span class=\"std std-ref\">Vector2</span></a>, b: <a class=\"reference internal\" href=\"../class_vector2/#class-vector2\"><span class=\"std std-ref\">Vector2</span></a>, c: <a class=\"reference internal\" href=\"../class_vector2/#class-vector2\"><span class=\"std std-ref\">Vector2</span></a>) <abbr title=\"This method has no side effects. It doesn't modify any of the instance's member variables.\">const</abbr></p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"../class_float/#class-float\"><span class=\"std std-ref\">float</span></a></p></td>\n<td><p><a class=\"reference internal\" href=\"#class-geometry2d-method-segment-intersects-circle\"><span class=\"std std-ref\">segment_intersects_circle</span></a>(segment_from: <a class=\"reference internal\" href=\"../class_vector2/#class-vector2\"><span class=\"std std-ref\">Vector2</span></a>, segment_to: <a class=\"reference internal\" href=\"../class_vector2/#class-vector2\"><span class=\"std std-ref\">Vector2</span></a>, circle_position: <a class=\"reference internal\" href=\"../class_vector2/#class-vector2\"><span class=\"std std-ref\">Vector2</span></a>, circle_radius: <a class=\"reference internal\" href=\"../class_float/#class-float\"><span class=\"std std-ref\">float</span></a>)</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"../class_variant/#class-variant\"><span class=\"std std-ref\">Variant</span></a></p></td>\n<td><p><a class=\"reference internal\" href=\"#class-geometry2d-method-segment-intersects-segment\"><span class=\"std std-ref\">segment_intersects_segment</span></a>(from_a: <a class=\"reference internal\" href=\"../class_vector2/#class-vector2\"><span class=\"std std-ref\">Vector2</span></a>, to_a: <a class=\"reference internal\" href=\"../class_vector2/#class-vector2\"><span class=\"std std-ref\">Vector2</span></a>, from_b: <a class=\"reference internal\" href=\"../class_vector2/#class-vector2\"><span class=\"std std-ref\">Vector2</span></a>, to_b: <a class=\"reference internal\" href=\"../class_vector2/#class-vector2\"><span class=\"std std-ref\">Vector2</span></a>)</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"../class_packedint32array/#class-packedint32array\"><span class=\"std std-ref\">PackedInt32Array</span></a></p></td>\n<td><p><a class=\"reference internal\" href=\"#class-geometry2d-method-triangulate-delaunay\"><span class=\"std std-ref\">triangulate_delaunay</span></a>(points: <a class=\"reference internal\" href=\"../class_packedvector2array/#class-packedvector2array\"><span class=\"std std-ref\">PackedVector2Array</span></a>)</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"../class_packedint32array/#class-packedint32array\"><span class=\"std std-ref\">PackedInt32Array</span></a></p></td>\n<td><p><a class=\"reference internal\" href=\"#class-geometry2d-method-triangulate-polygon\"><span class=\"std std-ref\">triangulate_polygon</span></a>(polygon: <a class=\"reference internal\" href=\"../class_packedvector2array/#class-packedvector2array\"><span class=\"std std-ref\">PackedVector2Array</span></a>)</p></td>\n</tr>\n</tbody>\n</table>\n</section>\n<hr class=\"classref-section-separator docutils\" />\n<section class=\"classref-descriptions-group\" id=\"enumerations\">\n<h2>Enumerations<a class=\"headerlink\" href=\"#enumerations\" title=\"Link to this heading\">\uf0c1</a></h2>\n<p class=\"classref-enumeration\" id=\"enum-geometry2d-polybooleanoperation\">enum <strong>PolyBooleanOperation</strong>: <a class=\"reference internal\" href=\"#enum-geometry2d-polybooleanoperation\"><span class=\"std std-ref\">\ud83d\udd17</span></a></p>\n<p class=\"classref-enumeration-constant\" id=\"class-geometry2d-constant-operation-union\"><a class=\"reference internal\" href=\"#enum-geometry2d-polybooleanoperation\"><span class=\"std std-ref\">PolyBooleanOperation</span></a> <strong>OPERATION_UNION</strong> = <code class=\"docutils literal notranslate\"><span class=\"pre\">0</span></code></p>\n<p>Create regions where either subject or clip polygons (or both) are filled.</p>\n<p class=\"classref-enumeration-constant\" id=\"class-geometry2d-constant-operation-difference\"><a class=\"reference internal\" href=\"#enum-geometry2d-polybooleanoperation\"><span class=\"std std-ref\">PolyBooleanOperation</span></a> <strong>OPERATION_DIFFERENCE</strong> = <code class=\"docutils literal notranslate\"><span class=\"pre\">1</span></code></p>\n<p>Create regions where subject polygons are filled except where clip polygons are filled.</p>\n<p class=\"classref-enumeration-constant\" id=\"class-geometry2d-constant-operation-intersection\"><a class=\"reference internal\" href=\"#enum-geometry2d-polybooleanoperation\"><span class=\"std std-ref\">PolyBooleanOperation</span></a> <strong>OPERATION_INTERSECTION</strong> = <code class=\"docutils literal notranslate\"><span class=\"pre\">2</span></code></p>\n<p>Create regions where both subject and clip polygons are filled.</p>\n<p class=\"classref-enumeration-constant\" id=\"class-geometry2d-constant-operation-xor\"><a class=\"reference internal\" href=\"#enum-geometry2d-polybooleanoperation\"><span class=\"std std-ref\">PolyBooleanOperation</span></a> <strong>OPERATION_XOR</strong> = <code class=\"docutils literal notranslate\"><span class=\"pre\">3</span></code></p>\n<p>Create regions where either subject or clip polygons are filled but not where both are filled.</p>\n<hr class=\"classref-item-separator docutils\" />\n<p class=\"classref-enumeration\" id=\"enum-geometry2d-polyjointype\">enum <strong>PolyJoinType</strong>: <a class=\"reference internal\" href=\"#enum-geometry2d-polyjointype\"><span class=\"std std-ref\">\ud83d\udd17</span></a></p>\n<p class=\"classref-enumeration-constant\" id=\"class-geometry2d-constant-join-square\"><a class=\"reference internal\" href=\"#enum-geometry2d-polyjointype\"><span class=\"std std-ref\">PolyJoinType</span></a> <strong>JOIN_SQUARE</strong> = <code class=\"docutils literal notranslate\"><span class=\"pre\">0</span></code></p>\n<p>Squaring is applied uniformally at all convex edge joins at <code class=\"docutils literal notranslate\"><span class=\"pre\">1</span> <span class=\"pre\">*</span> <span class=\"pre\">delta</span></code>.</p>\n<p class=\"classref-enumeration-constant\" id=\"class-geometry2d-constant-join-round\"><a class=\"reference internal\" href=\"#enum-geometry2d-polyjointype\"><span class=\"std std-ref\">PolyJoinType</span></a> <strong>JOIN_ROUND</strong> = <code class=\"docutils literal notranslate\"><span class=\"pre\">1</span></code></p>\n<p>While flattened paths can never perfectly trace an arc, they are approximated by a series of arc chords.</p>\n<p class=\"classref-enumeration-constant\" id=\"class-geometry2d-constant-join-miter\"><a class=\"reference internal\" href=\"#enum-geometry2d-polyjointype\"><span class=\"std std-ref\">PolyJoinType</span></a> <strong>JOIN_MITER</strong> = <code class=\"docutils literal notranslate\"><span class=\"pre\">2</span></code></p>\n<p>There's a necessary limit to mitered joins since offsetting edges that join at very acute angles will produce excessively long and narrow &quot;spikes&quot;. For any given edge join, when miter offsetting would exceed that maximum distance, &quot;square&quot; joining is applied.</p>\n<hr class=\"classref-item-separator docutils\" />\n<p class=\"classref-enumeration\" id=\"enum-geometry2d-polyendtype\">enum <strong>PolyEndType</strong>: <a class=\"reference internal\" href=\"#enum-geometry2d-polyendtype\"><span class=\"std std-ref\">\ud83d\udd17</span></a></p>\n<p class=\"classref-enumeration-constant\" id=\"class-geometry2d-constant-end-polygon\"><a class=\"reference internal\" href=\"#enum-geometry2d-polyendtype\"><span class=\"std std-ref\">PolyEndType</span></a> <strong>END_POLYGON</strong> = <code class=\"docutils literal notranslate\"><span class=\"pre\">0</span></code></p>\n<p>Endpoints are joined using the <a class=\"reference internal\" href=\"#enum-geometry2d-polyjointype\"><span class=\"std std-ref\">PolyJoinType</span></a> value and the path filled as a polygon.</p>\n<p class=\"classref-enumeration-constant\" id=\"class-geometry2d-constant-end-joined\"><a class=\"reference internal\" href=\"#enum-geometry2d-polyendtype\"><span class=\"std std-ref\">PolyEndType</span></a> <strong>END_JOINED</strong> = <code class=\"docutils literal notranslate\"><span class=\"pre\">1</span></code></p>\n<p>Endpoints are joined using the <a class=\"reference internal\" href=\"#enum-geometry2d-polyjointype\"><span class=\"std std-ref\">PolyJoinType</span></a> value and the path filled as a polyline.</p>\n<p class=\"classref-enumeration-constant\" id=\"class-geometry2d-constant-end-butt\"><a class=\"reference internal\" href=\"#enum-geometry2d-polyendtype\"><span class=\"std std-ref\">PolyEndType</span></a> <strong>END_BUTT</strong> = <code class=\"docutils literal notranslate\"><span class=\"pre\">2</span></code></p>\n<p>Endpoints are squared off with no extension.</p>\n<p class=\"classref-enumeration-constant\" id=\"class-geometry2d-constant-end-square\"><a class=\"reference internal\" href=\"#enum-geometry2d-polyendtype\"><span class=\"std std-ref\">PolyEndType</span></a> <strong>END_SQUARE</strong> = <code class=\"docutils literal notranslate\"><span class=\"pre\">3</span></code></p>\n<p>Endpoints are squared off and extended by <code class=\"docutils literal notranslate\"><span class=\"pre\">delta</span></code> units.</p>\n<p class=\"classref-enumeration-constant\" id=\"class-geometry2d-constant-end-round\"><a class=\"reference internal\" href=\"#enum-geometry2d-polyendtype\"><span class=\"std std-ref\">PolyEndType</span></a> <strong>END_ROUND</strong> = <code class=\"docutils literal notranslate\"><span class=\"pre\">4</span></code></p>\n<p>Endpoints are rounded off and extended by <code class=\"docutils literal notranslate\"><span class=\"pre\">delta</span></code> units.</p>\n</section>\n<hr class=\"classref-section-separator docutils\" />\n<section class=\"classref-descriptions-group\" id=\"method-descriptions\">\n<h2>Method Descriptions<a class=\"headerlink\" href=\"#method-descriptions\" title=\"Link to this heading\">\uf0c1</a></h2>\n<p class=\"classref-method\" id=\"class-geometry2d-method-bresenham-line\"><a class=\"reference internal\" href=\"../class_array/#class-array\"><span class=\"std std-ref\">Array</span></a>[<a class=\"reference internal\" href=\"../class_vector2i/#class-vector2i\"><span class=\"std std-ref\">Vector2i</span></a>] <strong>bresenham_line</strong>(from: <a class=\"reference internal\" href=\"../class_vector2i/#class-vector2i\"><span class=\"std std-ref\">Vector2i</span></a>, to: <a class=\"reference internal\" href=\"../class_vector2i/#class-vector2i\"><span class=\"std std-ref\">Vector2i</span></a>) <a class=\"reference internal\" href=\"#class-geometry2d-method-bresenham-line\"><span class=\"std std-ref\">\ud83d\udd17</span></a></p>\n<p>Returns the <a class=\"reference external\" href=\"https://en.wikipedia.org/wiki/Bresenham%27s_line_algorithm\">Bresenham line</a> between the <code class=\"docutils literal notranslate\"><span class=\"pre\">from</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">to</span></code> points. A Bresenham line is a series of pixels that draws a line and is always 1-pixel thick on every row and column of the drawing (never more, never less).</p>\n<p>Example code to draw a line between two <a class=\"reference internal\" href=\"../class_marker2d/#class-marker2d\"><span class=\"std std-ref\">Marker2D</span></a> nodes using a series of <a class=\"reference internal\" href=\"../class_canvasitem/#class-canvasitem-method-draw-rect\"><span class=\"std std-ref\">CanvasItem.draw_rect()</span></a> calls:</p>\n<div class=\"highlight-gdscript notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"k\">func</span><span class=\"w\"> </span><span class=\"nf nf-Declaration\">_draw</span><span class=\"p\">():</span>\n<span class=\"w\">    </span><span class=\"k k-ControlFlow\">for</span><span class=\"w\"> </span><span class=\"n\">pixel</span><span class=\"w\"> </span><span class=\"ow\">in</span><span class=\"w\"> </span><span class=\"nb\">Geometry2D</span><span class=\"o\">.</span><span class=\"nf\">bresenham_line</span><span class=\"p\">(</span><span class=\"sx\">$MarkerA</span><span class=\"o\">.</span><span class=\"vi\">position</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"sx\">$MarkerB</span><span class=\"o\">.</span><span class=\"vi\">position</span><span class=\"p\">):</span>\n<span class=\"w\">        </span><span class=\"nf\">draw_rect</span><span class=\"p\">(</span><span class=\"nb nb-Type\">Rect2</span><span class=\"p\">(</span><span class=\"n\">pixel</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nb nb-Type\">Vector2</span><span class=\"o\">.</span><span class=\"vi\">ONE</span><span class=\"p\">),</span><span class=\"w\"> </span><span class=\"nb nb-Type\">Color</span><span class=\"o\">.</span><span class=\"vi\">WHITE</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<hr class=\"classref-item-separator docutils\" />\n<p class=\"classref-method\" id=\"class-geometry2d-method-clip-polygons\"><a class=\"reference internal\" href=\"../class_array/#class-array\"><span class=\"std std-ref\">Array</span></a>[<a class=\"reference internal\" href=\"../class_packedvector2array/#class-packedvector2array\"><span class=\"std std-ref\">PackedVector2Array</span></a>] <strong>clip_polygons</strong>(polygon_a: <a class=\"reference internal\" href=\"../class_packedvector2array/#class-packedvector2array\"><span class=\"std std-ref\">PackedVector2Array</span></a>, polygon_b: <a class=\"reference internal\" href=\"../class_packedvector2array/#class-packedvector2array\"><span class=\"std std-ref\">PackedVector2Array</span></a>) <a class=\"reference internal\" href=\"#class-geometry2d-method-clip-polygons\"><span class=\"std std-ref\">\ud83d\udd17</span></a></p>\n<p>Clips <code class=\"docutils literal notranslate\"><span class=\"pre\">polygon_a</span></code> against <code class=\"docutils literal notranslate\"><span class=\"pre\">polygon_b</span></code> and returns an array of clipped polygons. This performs <a class=\"reference internal\" href=\"#class-geometry2d-constant-operation-difference\"><span class=\"std std-ref\">OPERATION_DIFFERENCE</span></a> between polygons. Returns an empty array if <code class=\"docutils literal notranslate\"><span class=\"pre\">polygon_b</span></code> completely overlaps <code class=\"docutils literal notranslate\"><span class=\"pre\">polygon_a</span></code>.</p>\n<p>If <code class=\"docutils literal notranslate\"><span class=\"pre\">polygon_b</span></code> is enclosed by <code class=\"docutils literal notranslate\"><span class=\"pre\">polygon_a</span></code>, returns an outer polygon (boundary) and inner polygon (hole) which could be distinguished by calling <a class=\"reference internal\" href=\"#class-geometry2d-method-is-polygon-clockwise\"><span class=\"std std-ref\">is_polygon_clockwise()</span></a>.</p>\n<hr class=\"classref-item-separator docutils\" />\n<p class=\"classref-method\" id=\"class-geometry2d-method-clip-polyline-with-polygon\"><a class=\"reference internal\" href=\"../class_array/#class-array\"><span class=\"std std-ref\">Array</span></a>[<a class=\"reference internal\" href=\"../class_packedvector2array/#class-packedvector2array\"><span class=\"std std-ref\">PackedVector2Array</span></a>] <strong>clip_polyline_with_polygon</strong>(polyline: <a class=\"reference internal\" href=\"../class_packedvector2array/#class-packedvector2array\"><span class=\"std std-ref\">PackedVector2Array</span></a>, polygon: <a class=\"reference internal\" href=\"../class_packedvector2array/#class-packedvector2array\"><span class=\"std std-ref\">PackedVector2Array</span></a>) <a class=\"reference internal\" href=\"#class-geometry2d-method-clip-polyline-with-polygon\"><span class=\"std std-ref\">\ud83d\udd17</span></a></p>\n<p>Clips <code class=\"docutils literal notranslate\"><span class=\"pre\">polyline</span></code> against <code class=\"docutils literal notranslate\"><span class=\"pre\">polygon</span></code> and returns an array of clipped polylines. This performs <a class=\"reference internal\" href=\"#class-geometry2d-constant-operation-difference\"><span class=\"std std-ref\">OPERATION_DIFFERENCE</span></a> between the polyline and the polygon. This operation can be thought of as cutting a line with a closed shape.</p>\n<hr class=\"classref-item-separator docutils\" />\n<p class=\"classref-method\" id=\"class-geometry2d-method-convex-hull\"><a class=\"reference internal\" href=\"../class_packedvector2array/#class-packedvector2array\"><span class=\"std std-ref\">PackedVector2Array</span></a> <strong>convex_hull</strong>(points: <a class=\"reference internal\" href=\"../class_packedvector2array/#class-packedvector2array\"><span class=\"std std-ref\">PackedVector2Array</span></a>) <a class=\"reference internal\" href=\"#class-geometry2d-method-convex-hull\"><span class=\"std std-ref\">\ud83d\udd17</span></a></p>\n<p>Given an array of <a class=\"reference internal\" href=\"../class_vector2/#class-vector2\"><span class=\"std std-ref\">Vector2</span></a>s, returns the convex hull as a list of points in counterclockwise order. The last point is the same as the first one.</p>\n<hr class=\"classref-item-separator docutils\" />\n<p class=\"classref-method\" id=\"class-geometry2d-method-decompose-polygon-in-convex\"><a class=\"reference internal\" href=\"../class_array/#class-array\"><span class=\"std std-ref\">Array</span></a>[<a class=\"reference internal\" href=\"../class_packedvector2array/#class-packedvector2array\"><span class=\"std std-ref\">PackedVector2Array</span></a>] <strong>decompose_polygon_in_convex</strong>(polygon: <a class=\"reference internal\" href=\"../class_packedvector2array/#class-packedvector2array\"><span class=\"std std-ref\">PackedVector2Array</span></a>) <a class=\"reference internal\" href=\"#class-geometry2d-method-decompose-polygon-in-convex\"><span class=\"std std-ref\">\ud83d\udd17</span></a></p>\n<p>Decomposes the <code class=\"docutils literal notranslate\"><span class=\"pre\">polygon</span></code> into multiple convex hulls and returns an array of <a class=\"reference internal\" href=\"../class_packedvector2array/#class-packedvector2array\"><span class=\"std std-ref\">PackedVector2Array</span></a>.</p>\n<hr class=\"classref-item-separator docutils\" />\n<p class=\"classref-method\" id=\"class-geometry2d-method-exclude-polygons\"><a class=\"reference internal\" href=\"../class_array/#class-array\"><span class=\"std std-ref\">Array</span></a>[<a class=\"reference internal\" href=\"../class_packedvector2array/#class-packedvector2array\"><span class=\"std std-ref\">PackedVector2Array</span></a>] <strong>exclude_polygons</strong>(polygon_a: <a class=\"reference internal\" href=\"../class_packedvector2array/#class-packedvector2array\"><span class=\"std std-ref\">PackedVector2Array</span></a>, polygon_b: <a class=\"reference internal\" href=\"../class_packedvector2array/#class-packedvector2array\"><span class=\"std std-ref\">PackedVector2Array</span></a>) <a class=\"reference internal\" href=\"#class-geometry2d-method-exclude-polygons\"><span class=\"std std-ref\">\ud83d\udd17</span></a></p>\n<p>Mutually excludes common area defined by intersection of <code class=\"docutils literal notranslate\"><span class=\"pre\">polygon_a</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">polygon_b</span></code> (see <a class=\"reference internal\" href=\"#class-geometry2d-method-intersect-polygons\"><span class=\"std std-ref\">intersect_polygons()</span></a>) and returns an array of excluded polygons. This performs <a class=\"reference internal\" href=\"#class-geometry2d-constant-operation-xor\"><span class=\"std std-ref\">OPERATION_XOR</span></a> between polygons. In other words, returns all but common area between polygons.</p>\n<p>The operation may result in an outer polygon (boundary) and inner polygon (hole) produced which could be distinguished by calling <a class=\"reference internal\" href=\"#class-geometry2d-method-is-polygon-clockwise\"><span class=\"std std-ref\">is_polygon_clockwise()</span></a>.</p>\n<hr class=\"classref-item-separator docutils\" />\n<p class=\"classref-method\" id=\"class-geometry2d-method-get-closest-point-to-segment\"><a class=\"reference internal\" href=\"../class_vector2/#class-vector2\"><span class=\"std std-ref\">Vector2</span></a> <strong>get_closest_point_to_segment</strong>(point: <a class=\"reference internal\" href=\"../class_vector2/#class-vector2\"><span class=\"std std-ref\">Vector2</span></a>, s1: <a class=\"reference internal\" href=\"../class_vector2/#class-vector2\"><span class=\"std std-ref\">Vector2</span></a>, s2: <a class=\"reference internal\" href=\"../class_vector2/#class-vector2\"><span class=\"std std-ref\">Vector2</span></a>) <a class=\"reference internal\" href=\"#class-geometry2d-method-get-closest-point-to-segment\"><span class=\"std std-ref\">\ud83d\udd17</span></a></p>\n<p>Returns the 2D point on the 2D segment (<code class=\"docutils literal notranslate\"><span class=\"pre\">s1</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">s2</span></code>) that is closest to <code class=\"docutils literal notranslate\"><span class=\"pre\">point</span></code>. The returned point will always be inside the specified segment.</p>\n<hr class=\"classref-item-separator docutils\" />\n<p class=\"classref-method\" id=\"class-geometry2d-method-get-closest-point-to-segment-uncapped\"><a class=\"reference internal\" href=\"../class_vector2/#class-vector2\"><span class=\"std std-ref\">Vector2</span></a> <strong>get_closest_point_to_segment_uncapped</strong>(point: <a class=\"reference internal\" href=\"../class_vector2/#class-vector2\"><span class=\"std std-ref\">Vector2</span></a>, s1: <a class=\"reference internal\" href=\"../class_vector2/#class-vector2\"><span class=\"std std-ref\">Vector2</span></a>, s2: <a class=\"reference internal\" href=\"../class_vector2/#class-vector2\"><span class=\"std std-ref\">Vector2</span></a>) <a class=\"reference internal\" href=\"#class-geometry2d-method-get-closest-point-to-segment-uncapped\"><span class=\"std std-ref\">\ud83d\udd17</span></a></p>\n<p>Returns the 2D point on the 2D line defined by (<code class=\"docutils literal notranslate\"><span class=\"pre\">s1</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">s2</span></code>) that is closest to <code class=\"docutils literal notranslate\"><span class=\"pre\">point</span></code>. The returned point can be inside the segment (<code class=\"docutils literal notranslate\"><span class=\"pre\">s1</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">s2</span></code>) or outside of it, i.e. somewhere on the line extending from the segment.</p>\n<hr class=\"classref-item-separator docutils\" />\n<p class=\"classref-method\" id=\"class-geometry2d-method-get-closest-points-between-segments\"><a class=\"reference internal\" href=\"../class_packedvector2array/#class-packedvector2array\"><span class=\"std std-ref\">PackedVector2Array</span></a> <strong>get_closest_points_between_segments</strong>(p1: <a class=\"reference internal\" href=\"../class_vector2/#class-vector2\"><span class=\"std std-ref\">Vector2</span></a>, q1: <a class=\"reference internal\" href=\"../class_vector2/#class-vector2\"><span class=\"std std-ref\">Vector2</span></a>, p2: <a class=\"reference internal\" href=\"../class_vector2/#class-vector2\"><span class=\"std std-ref\">Vector2</span></a>, q2: <a class=\"reference internal\" href=\"../class_vector2/#class-vector2\"><span class=\"std std-ref\">Vector2</span></a>) <a class=\"reference internal\" href=\"#class-geometry2d-method-get-closest-points-between-segments\"><span class=\"std std-ref\">\ud83d\udd17</span></a></p>\n<p>Given the two 2D segments (<code class=\"docutils literal notranslate\"><span class=\"pre\">p1</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">q1</span></code>) and (<code class=\"docutils literal notranslate\"><span class=\"pre\">p2</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">q2</span></code>), finds those two points on the two segments that are closest to each other. Returns a <a class=\"reference internal\" href=\"../class_packedvector2array/#class-packedvector2array\"><span class=\"std std-ref\">PackedVector2Array</span></a> that contains this point on (<code class=\"docutils literal notranslate\"><span class=\"pre\">p1</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">q1</span></code>) as well the accompanying point on (<code class=\"docutils literal notranslate\"><span class=\"pre\">p2</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">q2</span></code>).</p>\n<hr class=\"classref-item-separator docutils\" />\n<p class=\"classref-method\" id=\"class-geometry2d-method-intersect-polygons\"><a class=\"reference internal\" href=\"../class_array/#class-array\"><span class=\"std std-ref\">Array</span></a>[<a class=\"reference internal\" href=\"../class_packedvector2array/#class-packedvector2array\"><span class=\"std std-ref\">PackedVector2Array</span></a>] <strong>intersect_polygons</strong>(polygon_a: <a class=\"reference internal\" href=\"../class_packedvector2array/#class-packedvector2array\"><span class=\"std std-ref\">PackedVector2Array</span></a>, polygon_b: <a class=\"reference internal\" href=\"../class_packedvector2array/#class-packedvector2array\"><span class=\"std std-ref\">PackedVector2Array</span></a>) <a class=\"reference internal\" href=\"#class-geometry2d-method-intersect-polygons\"><span class=\"std std-ref\">\ud83d\udd17</span></a></p>\n<p>Intersects <code class=\"docutils literal notranslate\"><span class=\"pre\">polygon_a</span></code> with <code class=\"docutils literal notranslate\"><span class=\"pre\">polygon_b</span></code> and returns an array of intersected polygons. This performs <a class=\"reference internal\" href=\"#class-geometry2d-constant-operation-intersection\"><span class=\"std std-ref\">OPERATION_INTERSECTION</span></a> between polygons. In other words, returns common area shared by polygons. Returns an empty array if no intersection occurs.</p>\n<p>The operation may result in an outer polygon (boundary) and inner polygon (hole) produced which could be distinguished by calling <a class=\"reference internal\" href=\"#class-geometry2d-method-is-polygon-clockwise\"><span class=\"std std-ref\">is_polygon_clockwise()</span></a>.</p>\n<hr class=\"classref-item-separator docutils\" />\n<p class=\"classref-method\" id=\"class-geometry2d-method-intersect-polyline-with-polygon\"><a class=\"reference internal\" href=\"../class_array/#class-array\"><span class=\"std std-ref\">Array</span></a>[<a class=\"reference internal\" href=\"../class_packedvector2array/#class-packedvector2array\"><span class=\"std std-ref\">PackedVector2Array</span></a>] <strong>intersect_polyline_with_polygon</strong>(polyline: <a class=\"reference internal\" href=\"../class_packedvector2array/#class-packedvector2array\"><span class=\"std std-ref\">PackedVector2Array</span></a>, polygon: <a class=\"reference internal\" href=\"../class_packedvector2array/#class-packedvector2array\"><span class=\"std std-ref\">PackedVector2Array</span></a>) <a class=\"reference internal\" href=\"#class-geometry2d-method-intersect-polyline-with-polygon\"><span class=\"std std-ref\">\ud83d\udd17</span></a></p>\n<p>Intersects <code class=\"docutils literal notranslate\"><span class=\"pre\">polyline</span></code> with <code class=\"docutils literal notranslate\"><span class=\"pre\">polygon</span></code> and returns an array of intersected polylines. This performs <a class=\"reference internal\" href=\"#class-geometry2d-constant-operation-intersection\"><span class=\"std std-ref\">OPERATION_INTERSECTION</span></a> between the polyline and the polygon. This operation can be thought of as chopping a line with a closed shape.</p>\n<hr class=\"classref-item-separator docutils\" />\n<p class=\"classref-method\" id=\"class-geometry2d-method-is-point-in-circle\"><a class=\"reference internal\" href=\"../class_bool/#class-bool\"><span class=\"std std-ref\">bool</span></a> <strong>is_point_in_circle</strong>(point: <a class=\"reference internal\" href=\"../class_vector2/#class-vector2\"><span class=\"std std-ref\">Vector2</span></a>, circle_position: <a class=\"reference internal\" href=\"../class_vector2/#class-vector2\"><span class=\"std std-ref\">Vector2</span></a>, circle_radius: <a class=\"reference internal\" href=\"../class_float/#class-float\"><span class=\"std std-ref\">float</span></a>) <a class=\"reference internal\" href=\"#class-geometry2d-method-is-point-in-circle\"><span class=\"std std-ref\">\ud83d\udd17</span></a></p>\n<p>Returns <code class=\"docutils literal notranslate\"><span class=\"pre\">true</span></code> if <code class=\"docutils literal notranslate\"><span class=\"pre\">point</span></code> is inside the circle or if it's located exactly <em>on</em> the circle's boundary, otherwise returns <code class=\"docutils literal notranslate\"><span class=\"pre\">false</span></code>.</p>\n<hr class=\"classref-item-separator docutils\" />\n<p class=\"classref-method\" id=\"class-geometry2d-method-is-point-in-polygon\"><a class=\"reference internal\" href=\"../class_bool/#class-bool\"><span class=\"std std-ref\">bool</span></a> <strong>is_point_in_polygon</strong>(point: <a class=\"reference internal\" href=\"../class_vector2/#class-vector2\"><span class=\"std std-ref\">Vector2</span></a>, polygon: <a class=\"reference internal\" href=\"../class_packedvector2array/#class-packedvector2array\"><span class=\"std std-ref\">PackedVector2Array</span></a>) <a class=\"reference internal\" href=\"#class-geometry2d-method-is-point-in-polygon\"><span class=\"std std-ref\">\ud83d\udd17</span></a></p>\n<p>Returns <code class=\"docutils literal notranslate\"><span class=\"pre\">true</span></code> if <code class=\"docutils literal notranslate\"><span class=\"pre\">point</span></code> is inside <code class=\"docutils literal notranslate\"><span class=\"pre\">polygon</span></code> or if it's located exactly <em>on</em> polygon's boundary, otherwise returns <code class=\"docutils literal notranslate\"><span class=\"pre\">false</span></code>.</p>\n<hr class=\"classref-item-separator docutils\" />\n<p class=\"classref-method\" id=\"class-geometry2d-method-is-polygon-clockwise\"><a class=\"reference internal\" href=\"../class_bool/#class-bool\"><span class=\"std std-ref\">bool</span></a> <strong>is_polygon_clockwise</strong>(polygon: <a class=\"reference internal\" href=\"../class_packedvector2array/#class-packedvector2array\"><span class=\"std std-ref\">PackedVector2Array</span></a>) <a class=\"reference internal\" href=\"#class-geometry2d-method-is-polygon-clockwise\"><span class=\"std std-ref\">\ud83d\udd17</span></a></p>\n<p>Returns <code class=\"docutils literal notranslate\"><span class=\"pre\">true</span></code> if <code class=\"docutils literal notranslate\"><span class=\"pre\">polygon</span></code>'s vertices are ordered in clockwise order, otherwise returns <code class=\"docutils literal notranslate\"><span class=\"pre\">false</span></code>.</p>\n<p><strong>Note:</strong> Assumes a Cartesian coordinate system where <code class=\"docutils literal notranslate\"><span class=\"pre\">+x</span></code> is right and <code class=\"docutils literal notranslate\"><span class=\"pre\">+y</span></code> is up. If using screen coordinates (<code class=\"docutils literal notranslate\"><span class=\"pre\">+y</span></code> is down), the result will need to be flipped (i.e. a <code class=\"docutils literal notranslate\"><span class=\"pre\">true</span></code> result will indicate counter-clockwise).</p>\n<hr class=\"classref-item-separator docutils\" />\n<p class=\"classref-method\" id=\"class-geometry2d-method-line-intersects-line\"><a class=\"reference internal\" href=\"../class_variant/#class-variant\"><span class=\"std std-ref\">Variant</span></a> <strong>line_intersects_line</strong>(from_a: <a class=\"reference internal\" href=\"../class_vector2/#class-vector2\"><span class=\"std std-ref\">Vector2</span></a>, dir_a: <a class=\"reference internal\" href=\"../class_vector2/#class-vector2\"><span class=\"std std-ref\">Vector2</span></a>, from_b: <a class=\"reference internal\" href=\"../class_vector2/#class-vector2\"><span class=\"std std-ref\">Vector2</span></a>, dir_b: <a class=\"reference internal\" href=\"../class_vector2/#class-vector2\"><span class=\"std std-ref\">Vector2</span></a>) <a class=\"reference internal\" href=\"#class-geometry2d-method-line-intersects-line\"><span class=\"std std-ref\">\ud83d\udd17</span></a></p>\n<p>Returns the point of intersection between the two lines (<code class=\"docutils literal notranslate\"><span class=\"pre\">from_a</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">dir_a</span></code>) and (<code class=\"docutils literal notranslate\"><span class=\"pre\">from_b</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">dir_b</span></code>). Returns a <a class=\"reference internal\" href=\"../class_vector2/#class-vector2\"><span class=\"std std-ref\">Vector2</span></a>, or <code class=\"docutils literal notranslate\"><span class=\"pre\">null</span></code> if the lines are parallel.</p>\n<p><code class=\"docutils literal notranslate\"><span class=\"pre\">from</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">dir</span></code> are <em>not</em> endpoints of a line segment or ray but the slope (<code class=\"docutils literal notranslate\"><span class=\"pre\">dir</span></code>) and a known point (<code class=\"docutils literal notranslate\"><span class=\"pre\">from</span></code>) on that line.</p>\n<div class=\"sphinx-tabs docutils container\">\n<div class=\"docutils container\">\n<div class=\"docutils container\">\n<div class=\"docutils container\">\n<p>GDScript</p>\n</div>\n</div>\n<div class=\"docutils container\">\n</div>\n<div class=\"highlight-gdscript notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"k\">var</span><span class=\"w\"> </span><span class=\"n\">from_a</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nb nb-Type\">Vector2</span><span class=\"o\">.</span><span class=\"vi\">ZERO</span>\n<span class=\"k\">var</span><span class=\"w\"> </span><span class=\"n\">dir_a</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nb nb-Type\">Vector2</span><span class=\"o\">.</span><span class=\"vi\">RIGHT</span>\n<span class=\"k\">var</span><span class=\"w\"> </span><span class=\"n\">from_b</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nb nb-Type\">Vector2</span><span class=\"o\">.</span><span class=\"vi\">DOWN</span>\n\n<span class=\"c1\"># Returns Vector2(1, 0)</span>\n<span class=\"nb\">Geometry2D</span><span class=\"o\">.</span><span class=\"nf\">line_intersects_line</span><span class=\"p\">(</span><span class=\"n\">from_a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">dir_a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">from_b</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nb nb-Type\">Vector2</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">))</span>\n<span class=\"c1\"># Returns Vector2(-1, 0)</span>\n<span class=\"nb\">Geometry2D</span><span class=\"o\">.</span><span class=\"nf\">line_intersects_line</span><span class=\"p\">(</span><span class=\"n\">from_a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">dir_a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">from_b</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nb nb-Type\">Vector2</span><span class=\"p\">(</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">))</span>\n<span class=\"c1\"># Returns null</span>\n<span class=\"nb\">Geometry2D</span><span class=\"o\">.</span><span class=\"nf\">line_intersects_line</span><span class=\"p\">(</span><span class=\"n\">from_a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">dir_a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">from_b</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nb nb-Type\">Vector2</span><span class=\"o\">.</span><span class=\"vi\">RIGHT</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n</div>\n<div class=\"docutils container\">\n<div class=\"docutils container\">\n<div class=\"docutils container\">\n<p>C#</p>\n</div>\n</div>\n<div class=\"docutils container\">\n</div>\n<div class=\"highlight-csharp notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"kt\">var</span><span class=\"w\"> </span><span class=\"n\">fromA</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Vector2</span><span class=\"p\">.</span><span class=\"n\">Zero</span><span class=\"p\">;</span>\n<span class=\"kt\">var</span><span class=\"w\"> </span><span class=\"n\">dirA</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Vector2</span><span class=\"p\">.</span><span class=\"n\">Right</span><span class=\"p\">;</span>\n<span class=\"kt\">var</span><span class=\"w\"> </span><span class=\"n\">fromB</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Vector2</span><span class=\"p\">.</span><span class=\"n\">Down</span><span class=\"p\">;</span>\n\n<span class=\"c1\">// Returns new Vector2(1, 0)</span>\n<span class=\"n\">Geometry2D</span><span class=\"p\">.</span><span class=\"n\">LineIntersectsLine</span><span class=\"p\">(</span><span class=\"n\">fromA</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">dirA</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">fromB</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">new</span><span class=\"w\"> </span><span class=\"n\">Vector2</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">));</span>\n<span class=\"c1\">// Returns new Vector2(-1, 0)</span>\n<span class=\"n\">Geometry2D</span><span class=\"p\">.</span><span class=\"n\">LineIntersectsLine</span><span class=\"p\">(</span><span class=\"n\">fromA</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">dirA</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">fromB</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">new</span><span class=\"w\"> </span><span class=\"n\">Vector2</span><span class=\"p\">(</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">));</span>\n<span class=\"c1\">// Returns null</span>\n<span class=\"n\">Geometry2D</span><span class=\"p\">.</span><span class=\"n\">LineIntersectsLine</span><span class=\"p\">(</span><span class=\"n\">fromA</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">dirA</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">fromB</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Vector2</span><span class=\"p\">.</span><span class=\"n\">Right</span><span class=\"p\">);</span>\n</pre></div>\n</div>\n</div>\n</div>\n<hr class=\"classref-item-separator docutils\" />\n<p class=\"classref-method\" id=\"class-geometry2d-method-make-atlas\"><a class=\"reference internal\" href=\"../class_dictionary/#class-dictionary\"><span class=\"std std-ref\">Dictionary</span></a> <strong>make_atlas</strong>(sizes: <a class=\"reference internal\" href=\"../class_packedvector2array/#class-packedvector2array\"><span class=\"std std-ref\">PackedVector2Array</span></a>) <a class=\"reference internal\" href=\"#class-geometry2d-method-make-atlas\"><span class=\"std std-ref\">\ud83d\udd17</span></a></p>\n<p>Given an array of <a class=\"reference internal\" href=\"../class_vector2/#class-vector2\"><span class=\"std std-ref\">Vector2</span></a>s representing tiles, builds an atlas. The returned dictionary has two keys: <code class=\"docutils literal notranslate\"><span class=\"pre\">points</span></code> is a <a class=\"reference internal\" href=\"../class_packedvector2array/#class-packedvector2array\"><span class=\"std std-ref\">PackedVector2Array</span></a> that specifies the positions of each tile, <code class=\"docutils literal notranslate\"><span class=\"pre\">size</span></code> contains the overall size of the whole atlas as <a class=\"reference internal\" href=\"../class_vector2i/#class-vector2i\"><span class=\"std std-ref\">Vector2i</span></a>.</p>\n<hr class=\"classref-item-separator docutils\" />\n<p class=\"classref-method\" id=\"class-geometry2d-method-merge-polygons\"><a class=\"reference internal\" href=\"../class_array/#class-array\"><span class=\"std std-ref\">Array</span></a>[<a class=\"reference internal\" href=\"../class_packedvector2array/#class-packedvector2array\"><span class=\"std std-ref\">PackedVector2Array</span></a>] <strong>merge_polygons</strong>(polygon_a: <a class=\"reference internal\" href=\"../class_packedvector2array/#class-packedvector2array\"><span class=\"std std-ref\">PackedVector2Array</span></a>, polygon_b: <a class=\"reference internal\" href=\"../class_packedvector2array/#class-packedvector2array\"><span class=\"std std-ref\">PackedVector2Array</span></a>) <a class=\"reference internal\" href=\"#class-geometry2d-method-merge-polygons\"><span class=\"std std-ref\">\ud83d\udd17</span></a></p>\n<p>Merges (combines) <code class=\"docutils literal notranslate\"><span class=\"pre\">polygon_a</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">polygon_b</span></code> and returns an array of merged polygons. This performs <a class=\"reference internal\" href=\"#class-geometry2d-constant-operation-union\"><span class=\"std std-ref\">OPERATION_UNION</span></a> between polygons.</p>\n<p>The operation may result in an outer polygon (boundary) and multiple inner polygons (holes) produced which could be distinguished by calling <a class=\"reference internal\" href=\"#class-geometry2d-method-is-polygon-clockwise\"><span class=\"std std-ref\">is_polygon_clockwise()</span></a>.</p>\n<hr class=\"classref-item-separator docutils\" />\n<p class=\"classref-method\" id=\"class-geometry2d-method-offset-polygon\"><a class=\"reference internal\" href=\"../class_array/#class-array\"><span class=\"std std-ref\">Array</span></a>[<a class=\"reference internal\" href=\"../class_packedvector2array/#class-packedvector2array\"><span class=\"std std-ref\">PackedVector2Array</span></a>] <strong>offset_polygon</strong>(polygon: <a class=\"reference internal\" href=\"../class_packedvector2array/#class-packedvector2array\"><span class=\"std std-ref\">PackedVector2Array</span></a>, delta: <a class=\"reference internal\" href=\"../class_float/#class-float\"><span class=\"std std-ref\">float</span></a>, join_type: <a class=\"reference internal\" href=\"#enum-geometry2d-polyjointype\"><span class=\"std std-ref\">PolyJoinType</span></a> = 0) <a class=\"reference internal\" href=\"#class-geometry2d-method-offset-polygon\"><span class=\"std std-ref\">\ud83d\udd17</span></a></p>\n<p>Inflates or deflates <code class=\"docutils literal notranslate\"><span class=\"pre\">polygon</span></code> by <code class=\"docutils literal notranslate\"><span class=\"pre\">delta</span></code> units (pixels). If <code class=\"docutils literal notranslate\"><span class=\"pre\">delta</span></code> is positive, makes the polygon grow outward. If <code class=\"docutils literal notranslate\"><span class=\"pre\">delta</span></code> is negative, shrinks the polygon inward. Returns an array of polygons because inflating/deflating may result in multiple discrete polygons. Returns an empty array if <code class=\"docutils literal notranslate\"><span class=\"pre\">delta</span></code> is negative and the absolute value of it approximately exceeds the minimum bounding rectangle dimensions of the polygon.</p>\n<p>Each polygon's vertices will be rounded as determined by <code class=\"docutils literal notranslate\"><span class=\"pre\">join_type</span></code>.</p>\n<p>The operation may result in an outer polygon (boundary) and inner polygon (hole) produced which could be distinguished by calling <a class=\"reference internal\" href=\"#class-geometry2d-method-is-polygon-clockwise\"><span class=\"std std-ref\">is_polygon_clockwise()</span></a>.</p>\n<p><strong>Note:</strong> To translate the polygon's vertices specifically, multiply them to a <a class=\"reference internal\" href=\"../class_transform2d/#class-transform2d\"><span class=\"std std-ref\">Transform2D</span></a>:</p>\n<div class=\"sphinx-tabs docutils container\">\n<div class=\"docutils container\">\n<div class=\"docutils container\">\n<div class=\"docutils container\">\n<p>GDScript</p>\n</div>\n</div>\n<div class=\"docutils container\">\n</div>\n<div class=\"highlight-gdscript notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"k\">var</span><span class=\"w\"> </span><span class=\"n\">polygon</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nb nb-Type\">PackedVector2Array</span><span class=\"p\">([</span><span class=\"nb nb-Type\">Vector2</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">),</span><span class=\"w\"> </span><span class=\"nb nb-Type\">Vector2</span><span class=\"p\">(</span><span class=\"mi\">100</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">),</span><span class=\"w\"> </span><span class=\"nb nb-Type\">Vector2</span><span class=\"p\">(</span><span class=\"mi\">100</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">100</span><span class=\"p\">),</span><span class=\"w\"> </span><span class=\"nb nb-Type\">Vector2</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">100</span><span class=\"p\">)])</span>\n<span class=\"k\">var</span><span class=\"w\"> </span><span class=\"n\">offset</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nb nb-Type\">Vector2</span><span class=\"p\">(</span><span class=\"mi\">50</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">50</span><span class=\"p\">)</span>\n<span class=\"n\">polygon</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nb nb-Type\">Transform2D</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">offset</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"n\">polygon</span>\n<span class=\"nb nb-Function\">print</span><span class=\"p\">(</span><span class=\"n\">polygon</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"c1\"># Prints [(50.0, 50.0), (150.0, 50.0), (150.0, 150.0), (50.0, 150.0)]</span>\n</pre></div>\n</div>\n</div>\n<div class=\"docutils container\">\n<div class=\"docutils container\">\n<div class=\"docutils container\">\n<p>C#</p>\n</div>\n</div>\n<div class=\"docutils container\">\n</div>\n<div class=\"highlight-csharp notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"n\">Vector2</span><span class=\"p\">[]</span><span class=\"w\"> </span><span class=\"n\">polygon</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"k\">new</span><span class=\"w\"> </span><span class=\"n\">Vector2</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">),</span><span class=\"w\"> </span><span class=\"k\">new</span><span class=\"w\"> </span><span class=\"n\">Vector2</span><span class=\"p\">(</span><span class=\"mi\">100</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">),</span><span class=\"w\"> </span><span class=\"k\">new</span><span class=\"w\"> </span><span class=\"n\">Vector2</span><span class=\"p\">(</span><span class=\"mi\">100</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">100</span><span class=\"p\">),</span><span class=\"w\"> </span><span class=\"k\">new</span><span class=\"w\"> </span><span class=\"n\">Vector2</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">100</span><span class=\"p\">)];</span>\n<span class=\"kt\">var</span><span class=\"w\"> </span><span class=\"n\">offset</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">new</span><span class=\"w\"> </span><span class=\"n\">Vector2</span><span class=\"p\">(</span><span class=\"mi\">50</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">50</span><span class=\"p\">);</span>\n<span class=\"n\">polygon</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">new</span><span class=\"w\"> </span><span class=\"n\">Transform2D</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">offset</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"n\">polygon</span><span class=\"p\">;</span>\n<span class=\"n\">GD</span><span class=\"p\">.</span><span class=\"n\">Print</span><span class=\"p\">((</span><span class=\"n\">Variant</span><span class=\"p\">)</span><span class=\"n\">polygon</span><span class=\"p\">);</span><span class=\"w\"> </span><span class=\"c1\">// Prints [(50, 50), (150, 50), (150, 150), (50, 150)]</span>\n</pre></div>\n</div>\n</div>\n</div>\n<hr class=\"classref-item-separator docutils\" />\n<p class=\"classref-method\" id=\"class-geometry2d-method-offset-polyline\"><a class=\"reference internal\" href=\"../class_array/#class-array\"><span class=\"std std-ref\">Array</span></a>[<a class=\"reference internal\" href=\"../class_packedvector2array/#class-packedvector2array\"><span class=\"std std-ref\">PackedVector2Array</span></a>] <strong>offset_polyline</strong>(polyline: <a class=\"reference internal\" href=\"../class_packedvector2array/#class-packedvector2array\"><span class=\"std std-ref\">PackedVector2Array</span></a>, delta: <a class=\"reference internal\" href=\"../class_float/#class-float\"><span class=\"std std-ref\">float</span></a>, join_type: <a class=\"reference internal\" href=\"#enum-geometry2d-polyjointype\"><span class=\"std std-ref\">PolyJoinType</span></a> = 0, end_type: <a class=\"reference internal\" href=\"#enum-geometry2d-polyendtype\"><span class=\"std std-ref\">PolyEndType</span></a> = 3) <a class=\"reference internal\" href=\"#class-geometry2d-method-offset-polyline\"><span class=\"std std-ref\">\ud83d\udd17</span></a></p>\n<p>Inflates or deflates <code class=\"docutils literal notranslate\"><span class=\"pre\">polyline</span></code> by <code class=\"docutils literal notranslate\"><span class=\"pre\">delta</span></code> units (pixels), producing polygons. If <code class=\"docutils literal notranslate\"><span class=\"pre\">delta</span></code> is positive, makes the polyline grow outward. Returns an array of polygons because inflating/deflating may result in multiple discrete polygons. If <code class=\"docutils literal notranslate\"><span class=\"pre\">delta</span></code> is negative, returns an empty array.</p>\n<p>Each polygon's vertices will be rounded as determined by <code class=\"docutils literal notranslate\"><span class=\"pre\">join_type</span></code>.</p>\n<p>Each polygon's endpoints will be rounded as determined by <code class=\"docutils literal notranslate\"><span class=\"pre\">end_type</span></code>.</p>\n<p>The operation may result in an outer polygon (boundary) and inner polygon (hole) produced which could be distinguished by calling <a class=\"reference internal\" href=\"#class-geometry2d-method-is-polygon-clockwise\"><span class=\"std std-ref\">is_polygon_clockwise()</span></a>.</p>\n<hr class=\"classref-item-separator docutils\" />\n<p class=\"classref-method\" id=\"class-geometry2d-method-point-is-inside-triangle\"><a class=\"reference internal\" href=\"../class_bool/#class-bool\"><span class=\"std std-ref\">bool</span></a> <strong>point_is_inside_triangle</strong>(point: <a class=\"reference internal\" href=\"../class_vector2/#class-vector2\"><span class=\"std std-ref\">Vector2</span></a>, a: <a class=\"reference internal\" href=\"../class_vector2/#class-vector2\"><span class=\"std std-ref\">Vector2</span></a>, b: <a class=\"reference internal\" href=\"../class_vector2/#class-vector2\"><span class=\"std std-ref\">Vector2</span></a>, c: <a class=\"reference internal\" href=\"../class_vector2/#class-vector2\"><span class=\"std std-ref\">Vector2</span></a>) <abbr title=\"This method has no side effects. It doesn't modify any of the instance's member variables.\">const</abbr> <a class=\"reference internal\" href=\"#class-geometry2d-method-point-is-inside-triangle\"><span class=\"std std-ref\">\ud83d\udd17</span></a></p>\n<p>Returns if <code class=\"docutils literal notranslate\"><span class=\"pre\">point</span></code> is inside the triangle specified by <code class=\"docutils literal notranslate\"><span class=\"pre\">a</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">b</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">c</span></code>.</p>\n<hr class=\"classref-item-separator docutils\" />\n<p class=\"classref-method\" id=\"class-geometry2d-method-segment-intersects-circle\"><a class=\"reference internal\" href=\"../class_float/#class-float\"><span class=\"std std-ref\">float</span></a> <strong>segment_intersects_circle</strong>(segment_from: <a class=\"reference internal\" href=\"../class_vector2/#class-vector2\"><span class=\"std std-ref\">Vector2</span></a>, segment_to: <a class=\"reference internal\" href=\"../class_vector2/#class-vector2\"><span class=\"std std-ref\">Vector2</span></a>, circle_position: <a class=\"reference internal\" href=\"../class_vector2/#class-vector2\"><span class=\"std std-ref\">Vector2</span></a>, circle_radius: <a class=\"reference internal\" href=\"../class_float/#class-float\"><span class=\"std std-ref\">float</span></a>) <a class=\"reference internal\" href=\"#class-geometry2d-method-segment-intersects-circle\"><span class=\"std std-ref\">\ud83d\udd17</span></a></p>\n<p>Given the 2D segment (<code class=\"docutils literal notranslate\"><span class=\"pre\">segment_from</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">segment_to</span></code>), returns the position on the segment (as a number between 0 and 1) at which the segment hits the circle that is located at position <code class=\"docutils literal notranslate\"><span class=\"pre\">circle_position</span></code> and has radius <code class=\"docutils literal notranslate\"><span class=\"pre\">circle_radius</span></code>. If the segment does not intersect the circle, -1 is returned (this is also the case if the line extending the segment would intersect the circle, but the segment does not).</p>\n<hr class=\"classref-item-separator docutils\" />\n<p class=\"classref-method\" id=\"class-geometry2d-method-segment-intersects-segment\"><a class=\"reference internal\" href=\"../class_variant/#class-variant\"><span class=\"std std-ref\">Variant</span></a> <strong>segment_intersects_segment</strong>(from_a: <a class=\"reference internal\" href=\"../class_vector2/#class-vector2\"><span class=\"std std-ref\">Vector2</span></a>, to_a: <a class=\"reference internal\" href=\"../class_vector2/#class-vector2\"><span class=\"std std-ref\">Vector2</span></a>, from_b: <a class=\"reference internal\" href=\"../class_vector2/#class-vector2\"><span class=\"std std-ref\">Vector2</span></a>, to_b: <a class=\"reference internal\" href=\"../class_vector2/#class-vector2\"><span class=\"std std-ref\">Vector2</span></a>) <a class=\"reference internal\" href=\"#class-geometry2d-method-segment-intersects-segment\"><span class=\"std std-ref\">\ud83d\udd17</span></a></p>\n<p>Checks if the two segments (<code class=\"docutils literal notranslate\"><span class=\"pre\">from_a</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">to_a</span></code>) and (<code class=\"docutils literal notranslate\"><span class=\"pre\">from_b</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">to_b</span></code>) intersect. If yes, return the point of intersection as <a class=\"reference internal\" href=\"../class_vector2/#class-vector2\"><span class=\"std std-ref\">Vector2</span></a>. If no intersection takes place, returns <code class=\"docutils literal notranslate\"><span class=\"pre\">null</span></code>.</p>\n<hr class=\"classref-item-separator docutils\" />\n<p class=\"classref-method\" id=\"class-geometry2d-method-triangulate-delaunay\"><a class=\"reference internal\" href=\"../class_packedint32array/#class-packedint32array\"><span class=\"std std-ref\">PackedInt32Array</span></a> <strong>triangulate_delaunay</strong>(points: <a class=\"reference internal\" href=\"../class_packedvector2array/#class-packedvector2array\"><span class=\"std std-ref\">PackedVector2Array</span></a>) <a class=\"reference internal\" href=\"#class-geometry2d-method-triangulate-delaunay\"><span class=\"std std-ref\">\ud83d\udd17</span></a></p>\n<p>Triangulates the area specified by discrete set of <code class=\"docutils literal notranslate\"><span class=\"pre\">points</span></code> such that no point is inside the circumcircle of any resulting triangle. Returns a <a class=\"reference internal\" href=\"../class_packedint32array/#class-packedint32array\"><span class=\"std std-ref\">PackedInt32Array</span></a> where each triangle consists of three consecutive point indices into <code class=\"docutils literal notranslate\"><span class=\"pre\">points</span></code> (i.e. the returned array will have <code class=\"docutils literal notranslate\"><span class=\"pre\">n</span> <span class=\"pre\">*</span> <span class=\"pre\">3</span></code> elements, with <code class=\"docutils literal notranslate\"><span class=\"pre\">n</span></code> being the number of found triangles). If the triangulation did not succeed, an empty <a class=\"reference internal\" href=\"../class_packedint32array/#class-packedint32array\"><span class=\"std std-ref\">PackedInt32Array</span></a> is returned.</p>\n<hr class=\"classref-item-separator docutils\" />\n<p class=\"classref-method\" id=\"class-geometry2d-method-triangulate-polygon\"><a class=\"reference internal\" href=\"../class_packedint32array/#class-packedint32array\"><span class=\"std std-ref\">PackedInt32Array</span></a> <strong>triangulate_polygon</strong>(polygon: <a class=\"reference internal\" href=\"../class_packedvector2array/#class-packedvector2array\"><span class=\"std std-ref\">PackedVector2Array</span></a>) <a class=\"reference internal\" href=\"#class-geometry2d-method-triangulate-polygon\"><span class=\"std std-ref\">\ud83d\udd17</span></a></p>\n<p>Triangulates the polygon specified by the points in <code class=\"docutils literal notranslate\"><span class=\"pre\">polygon</span></code>. Returns a <a class=\"reference internal\" href=\"../class_packedint32array/#class-packedint32array\"><span class=\"std std-ref\">PackedInt32Array</span></a> where each triangle consists of three consecutive point indices into <code class=\"docutils literal notranslate\"><span class=\"pre\">polygon</span></code> (i.e. the returned array will have <code class=\"docutils literal notranslate\"><span class=\"pre\">n</span> <span class=\"pre\">*</span> <span class=\"pre\">3</span></code> elements, with <code class=\"docutils literal notranslate\"><span class=\"pre\">n</span></code> being the number of found triangles). Output triangles will always be counter clockwise, and the contour will be flipped if it's clockwise. If the triangulation did not succeed, an empty <a class=\"reference internal\" href=\"../class_packedint32array/#class-packedint32array\"><span class=\"std std-ref\">PackedInt32Array</span></a> is returned.</p>\n</section>\n</section>\n", "metatags": "<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n", "rellinks": [["genindex", "General Index", "I", "index"], ["classes/class_geometry3d", "Geometry3D", "N", "next"], ["classes/class_gdextensionmanager", "GDExtensionManager", "P", "previous"]], "sourcename": "classes/class_geometry2d.rst.txt", "toc": "<ul>\n<li><a class=\"reference internal\" href=\"#\">Geometry2D</a><ul>\n<li><a class=\"reference internal\" href=\"#description\">Description</a></li>\n<li><a class=\"reference internal\" href=\"#methods\">Methods</a></li>\n<li><a class=\"reference internal\" href=\"#enumerations\">Enumerations</a></li>\n<li><a class=\"reference internal\" href=\"#method-descriptions\">Method Descriptions</a></li>\n</ul>\n</li>\n</ul>\n", "display_toc": true, "page_source_suffix": ".rst", "current_page_name": "classes/class_geometry2d", "sidebars": ["localtoc.html", "relations.html", "sourcelink.html", "searchbox.html"], "alabaster_version": "1.0.0", "alabaster_version_info": [1, 0, 0], "sphinx_version_info": [8, 1, 3, "final", 0], "READTHEDOCS": false}